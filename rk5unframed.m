


//SPECIAL CASE: no possible choice of frame (c, and basis element) exists. true for 1038 and 1041


U := [[1,2,3,4,7], [5,6,8,9,10], [1,2,3,4,5], [1,2,3,4,6], [1,2,3,4,8], [1,2,3,4,9], [1,2,3,4,10], [1,2,3,5,6], [1,2,3,5,7], [1,2,3,5,8], [1,2,3,5,9], [1,2,3,5,10], [1,2,3,6,7], [1,2,3,6,8], [1,2,3,6,9], [1,2,3,6,10], [1,2,3,7,8], [1,2,3,7,9], [1,2,3,7,10], [1,2,3,8,9], [1,2,3,8,10], [1,2,3,9,10], [1,2,4,5,6], [1,2,4,5,7], [1,2,4,5,8], [1,2,4,5,9], [1,2,4,5,10], [1,2,4,6,7], [1,2,4,6,8], [1,2,4,6,9], [1,2,4,6,10], [1,2,4,7,8], [1,2,4,7,9], [1,2,4,7,10], [1,2,4,8,9], [1,2,4,8,10], [1,2,4,9,10], [1,2,5,6,7], [1,2,5,6,8], [1,2,5,6,9], [1,2,5,6,10], [1,2,5,7,8], [1,2,5,7,9], [1,2,5,7,10], [1,2,5,8,9], [1,2,5,8,10], [1,2,5,9,10], [1,2,6,7,8], [1,2,6,7,9], [1,2,6,7,10], [1,2,6,8,9], [1,2,6,8,10], [1,2,6,9,10], [1,2,7,8,9], [1,2,7,8,10], [1,2,7,9,10], [1,2,8,9,10], [1,3,4,5,6], [1,3,4,5,7], [1,3,4,5,8], [1,3,4,5,9], [1,3,4,5,10], [1,3,4,6,7], [1,3,4,6,8], [1,3,4,6,9], [1,3,4,6,10], [1,3,4,7,8], [1,3,4,7,9], [1,3,4,7,10], [1,3,4,8,9], [1,3,4,8,10], [1,3,4,9,10], [1,3,5,6,7], [1,3,5,6,8], [1,3,5,6,9], [1,3,5,6,10], [1,3,5,7,8], [1,3,5,7,9], [1,3,5,7,10], [1,3,5,8,9], [1,3,5,8,10], [1,3,5,9,10], [1,3,6,7,8], [1,3,6,7,9], [1,3,6,7,10], [1,3,6,8,9], [1,3,6,8,10], [1,3,6,9,10], [1,3,7,8,9], [1,3,7,8,10], [1,3,7,9,10], [1,3,8,9,10], [1,4,5,6,7], [1,4,5,6,8], [1,4,5,6,9], [1,4,5,6,10], [1,4,5,7,8], [1,4,5,7,9], [1,4,5,7,10], [1,4,5,8,9], [1,4,5,8,10], [1,4,5,9,10], [1,4,6,7,8], [1,4,6,7,9], [1,4,6,7,10], [1,4,6,8,9], [1,4,6,8,10], [1,4,6,9,10], [1,4,7,8,9], [1,4,7,8,10], [1,4,7,9,10], [1,4,8,9,10], [1,5,6,7,8], [1,5,6,7,9], [1,5,6,7,10], [1,5,6,8,9], [1,5,6,8,10], [1,5,6,9,10], [1,5,7,8,9], [1,5,7,8,10], [1,5,7,9,10], [1,5,8,9,10], [1,6,7,8,9], [1,6,7,8,10], [1,6,7,9,10], [1,6,8,9,10], [1,7,8,9,10], [2,3,4,5,6], [2,3,4,5,7], [2,3,4,5,8], [2,3,4,5,9], [2,3,4,5,10], [2,3,4,6,7], [2,3,4,6,8], [2,3,4,6,9], [2,3,4,6,10], [2,3,4,7,8], [2,3,4,7,9], [2,3,4,7,10], [2,3,4,8,9], [2,3,4,8,10], [2,3,4,9,10], [2,3,5,6,7], [2,3,5,6,8], [2,3,5,6,9], [2,3,5,6,10], [2,3,5,7,8], [2,3,5,7,9], [2,3,5,7,10], [2,3,5,8,9], [2,3,5,8,10], [2,3,5,9,10], [2,3,6,7,8], [2,3,6,7,9], [2,3,6,7,10], [2,3,6,8,9], [2,3,6,8,10], [2,3,6,9,10], [2,3,7,8,9], [2,3,7,8,10], [2,3,7,9,10], [2,3,8,9,10], [2,4,5,6,7], [2,4,5,6,8], [2,4,5,6,9], [2,4,5,6,10], [2,4,5,7,8], [2,4,5,7,9], [2,4,5,7,10], [2,4,5,8,9], [2,4,5,8,10], [2,4,5,9,10], [2,4,6,7,8], [2,4,6,7,9], [2,4,6,7,10], [2,4,6,8,9], [2,4,6,8,10], [2,4,6,9,10], [2,4,7,8,9], [2,4,7,8,10], [2,4,7,9,10], [2,4,8,9,10], [2,5,6,7,8], [2,5,6,7,9], [2,5,6,7,10], [2,5,6,8,9], [2,5,6,8,10], [2,5,6,9,10], [2,5,7,8,9], [2,5,7,8,10], [2,5,7,9,10], [2,5,8,9,10], [2,6,7,8,9], [2,6,7,8,10], [2,6,7,9,10], [2,6,8,9,10], [2,7,8,9,10], [3,4,5,6,7], [3,4,5,6,8], [3,4,5,6,9], [3,4,5,6,10], [3,4,5,7,8], [3,4,5,7,9], [3,4,5,7,10], [3,4,5,8,9], [3,4,5,8,10], [3,4,5,9,10], [3,4,6,7,8], [3,4,6,7,9], [3,4,6,7,10], [3,4,6,8,9], [3,4,6,8,10], [3,4,6,9,10], [3,4,7,8,9], [3,4,7,8,10], [3,4,7,9,10], [3,4,8,9,10], [3,5,6,7,8], [3,5,6,7,9], [3,5,6,7,10], [3,5,6,8,9], [3,5,6,8,10], [3,5,6,9,10], [3,5,7,8,9], [3,5,7,8,10], [3,5,7,9,10], [3,5,8,9,10], [3,6,7,8,9], [3,6,7,8,10], [3,6,7,9,10], [3,6,8,9,10], [3,7,8,9,10], [4,5,6,7,8], [4,5,6,7,9], [4,5,6,7,10], [4,5,6,8,9], [4,5,6,8,10], [4,5,6,9,10], [4,5,7,8,9], [4,5,7,8,10], [4,5,7,9,10], [4,5,8,9,10], [4,6,7,8,9], [4,6,7,8,10], [4,6,7,9,10], [4,6,8,9,10], [4,7,8,9,10], [5,6,7,8,9], [5,6,7,8,10], [5,6,7,9,10], [5,7,8,9,10], [6,7,8,9,10]];

function constructMinorsUnframed(M, indices, R, b)
    bcomp := {1,2,3,4,5,6,7,8,9,10} diff Set(b);
    bcomp := SetToSequence(bcomp);
    reorder := pmap<[1,2,3,4,5,6,7,8,9,10]->[1,2,3,4,5,6,7,8,9,10] | [<b[1],1>, <b[2], 2>, <b[3], 3>, <b[4], 4>, <b[5], 5>,  <bcomp[1],6>, <bcomp[2],7>, <bcomp[3], 8>, <bcomp[4], 9>, <bcomp[5], 10> ]>;
    return [ R!Determinant(Transpose(Matrix([ColumnSubmatrixRange(M, reorder(i), reorder(i)): i in ind]))) : ind in indices]; 
end function;

function normalizeCols(M, minors, R)
    xs := Matrix(5, 5, [R.i : i in [1..25]]);
    firstnotzer := [];
    for i in [1 .. 5] do
        for j in [1 .. 5] do
                if xs[j][i] notin minors and -xs[j][i] notin minors then
                    Append(~firstnotzer, xs[j][i] - R!1);
                break;
            end if;
        end for;
    end for;
    return firstnotzer;
end function;

function normalizeRows(M, minors, R)
    xs := Matrix(5, 5, [R.i : i in [1..25]]);
    firstnotzer := [];
    for i in [1 .. 5] do
        for j in [1 .. 5] do
                if xs[i][j] notin minors and -xs[i][j] notin minors then
                    Append(~firstnotzer, xs[i][j] - R!1);
                break;
            end if;
        end for;
    end for;
    return firstnotzer;
end function;

function saturateIdeal(eqns, basisminors, R)
    Isat := ideal<R| eqns >;
    for f in basisminors do
        Isat := Saturation(Isat, f);
    end for;
    return Isat;
end function;

function constructLambdaEqns(M, R)
    l := [R.i : i in [26 .. 35]];
    prod := M* DiagonalMatrix(l) * Transpose(M);
    leqns := [Vector(prod)[i] : i in [1 .. 25]];
    return leqns;
end function;

function strip(s) return Join(Split(Join(Split(s," "),""),"\n"),""); end function;


function doline(bases)
    R<[x]> := PolynomialRing(Rationals(), 35);
    xs := Matrix(5, 5, [R.i : i in [1..25]]);
    Id := ScalarMatrix(5,R!1);
    M := HorizontalJoin(Id, xs);
    nonbases :=  SetToSequence(Set(U) diff Set(bases)); 
    b := bases[1]; // pick a random basis;
    nonbasisminors :=constructMinorsUnframed(M, nonbases, R, b);
    //force the first nonzero entry of each column to be one
    nonzer := normalizeCols(M, nonbasisminors, R);
    //add in all the equations for each non-basis
    nonzercol := normalizeRows(M, nonbasisminors, R);

    eqns := nonbasisminors cat nonzer cat nonzercol;
    basisminors := constructMinorsUnframed(M, bases, R, b);

    I := Ideal(eqns);
    Isat := saturateIdeal(eqns, basisminors, R);
    l := [R.i : i in [26 .. 35]];
    prod := M* DiagonalMatrix(l) * Transpose(M); 

    gb := GroebnerBasis(Isat);
    d := Dimension(Isat);
    d := d - 10;
    leqns := constructLambdaEqns(M,R);
    selfdualeqns := gb cat leqns;
    selfdualI := ideal<R|selfdualeqns>;
    //sdIsat := Saturation(selfdualI, ideal<R| [x[i]: i in [26 .. 35]]>);

    sdIsat := Saturation(selfdualI, &*[x[i]: i in [26 .. 35]]);
    sdIsatelim := EliminationIdeal(sdIsat, {x[i] : i in [1 .. 25]});
    sdequalsreal := sdIsatelim eq Isat;
    if sdequalsreal then
        selfdualdim := Dimension(sdIsatelim) - 10;
        Q := quo<R | sdIsatelim>;
        Mspec := ChangeRing(M, Q);
    else
        Isdsat := sdIsatelim;
        for f in basisminors do
            Isdsat := Saturation(Isdsat, f);
        end for;
        sdIsatelim := Isdsat;
        selfdualdim := Dimension(sdIsatelim) - 10;
        Q := quo<R | sdIsatelim>;
        Mspec := ChangeRing(M, Q);
        sdequalsreal := sdIsatelim eq Isat;
    end if;

    output := [* bases, gb, d, Basis(sdIsatelim), selfdualdim, sdequalsreal, [Eltseq(r) : r in Rows(Mspec)] *];
    return output;

end function;

if assigned seq then
    SetColumns(0);
    SetAutoColumns(false);
    seq := eval seq;
    inputs := Split(Read("rk5matroids"), "\n");
    input := eval inputs[seq];
    output := doline(input);
    output := [* seq *] cat output;
    print strip(Join([Sprint(elt) : elt in output], ":"));
    exit;
end if;

